package properties

import (
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric-chaincode-go/shim"
	"github.com/johannww/phd-impl/chaincodes/carbon/state"
	v "github.com/johannww/phd-impl/chaincodes/carbon/vegetation"
)

const (
	PROPERTY_PREFIX       = "property"
	PROPERTY_CHUNK_PREFIX = "propertyChunk"
	COORDINATES_PREFIX    = "coords"
)

type Coordinates struct {
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
}

// PropertyChunk represents a chunk of a property.
// It exists because properties might have heterogeneous chunks.
// It points to the property because otherwise---if in a slice in the
// property struct---it could generate MVCC_READ_CONFLICT errors.
// See: https://github.com/hyperledger/fabric/issues/3748
type PropertyChunk struct {
	PropertyID uint64 `json:"propertyId"`
	// TODO: how do i generate an id for chunks?
	// Idea 1: use random numbers
	// Idea 2: use sequential numbers generated by the Property struct
	ChunkID          uint64              `json:"chunkId"`
	Coordinates      []Coordinates       `json:"coordinates"`
	VegetationsProps []v.VegetationProps `json:"vegetationsProps"`
}

var _ state.WorldStateManager = (*PropertyChunk)(nil)

func (propertychunk *PropertyChunk) FromWorldState(stub shim.ChaincodeStubInterface, keyAttributes []string) error {
	if len(keyAttributes) != 2 {
		return fmt.Errorf("invalid number of key attributes: %d", len(keyAttributes))
	}

	err := state.GetStateWithCompositeKey(stub, PROPERTY_CHUNK_PREFIX, keyAttributes, propertychunk)
	if err != nil {
		return fmt.Errorf("could not get property chunk from world state: %v", err)
	}

	return nil
}

func (propertychunk *PropertyChunk) ToWorldState(stub shim.ChaincodeStubInterface) error {
	err := state.PutStateWithCompositeKey(stub, PROPERTY_CHUNK_PREFIX, propertychunk.GetID(), propertychunk)
	if err != nil {
		return err
	}

	return nil
}

func (propertychunk *PropertyChunk) GetID() *[][]string {
	return &[][]string{{
		strconv.FormatUint(propertychunk.PropertyID, 10),
		strconv.FormatUint(propertychunk.ChunkID, 10),
	}}
}

// TODO: review how chunks should be loaded
type Property struct {
	OwnerID string `json:"ownerId"`
	ID      uint64 `json:"id"`
	// Chunks will not be marshalled to the world state via
	// this struct. Instead, it will be marshalled via the
	// PropertyChunk struct.
	Chunks []*PropertyChunk `json:"chunks"`
}

var _ state.WorldStateManager = (*Property)(nil)

func (property *Property) FromWorldState(stub shim.ChaincodeStubInterface, keyAttributes []string) error {
	err := state.GetStateWithCompositeKey(stub, PROPERTY_PREFIX, keyAttributes, property)
	if err != nil {
		return fmt.Errorf("could not get property from world state: %v", err)
	}

	property.Chunks, err = state.GetStatesByPartialCompositeKey[PropertyChunk](stub, PROPERTY_CHUNK_PREFIX, keyAttributes)
	if err != nil {
		return fmt.Errorf("could not get property chunks from world state: %v", err)
	}

	return nil

}

func (property *Property) ToWorldState(stub shim.ChaincodeStubInterface) error {
	chunks := property.Chunks
	property.Chunks = nil // do not marshal chunks in the property struct

	err := state.PutStateWithCompositeKey(stub, PROPERTY_PREFIX, property.GetID(), property)

	for _, chunk := range chunks {
		chunk.ToWorldState(stub)
	}

	// reset property chunks
	property.Chunks = chunks
	return err
}

func (property *Property) GetID() *[][]string {
	return &[][]string{{
		property.OwnerID,
		strconv.FormatUint(property.ID, 10),
	}}
}
