package auction

import (
	"crypto/ed25519"
	"crypto/sha512"
	"encoding/json"
	"fmt"

	cc_auction "github.com/johannww/phd-impl/chaincodes/carbon/auction"
	"github.com/johannww/phd-impl/tee_auction/go/report"
)

// type AuctionResultTEE struct {
// 	matched
// }

type SerializedAuctionResultTEE struct {
	// ResultBytes is a serialized OffChainIndepAuctionResult
	// Or OffChainCoupledAuctionResult
	ResultBytes []byte `json:"resultBytes"`
	// AmdReportBytes is a serialized &attest.SNPAttestationReport{}
	AmdReportBytes []byte `json:"reportBytes"`
	// AppSignature represents the signature with the key generated by the app
	// inside the TEE
	AppSignature []byte `json:"appSignature"`
	TEECertDer   []byte `json:"teeCertDer"`
}

// TODOHP: finish auction running on tee
func RunTEEAuction(
	serializedAD *cc_auction.SerializedAuctionData,
	privateKey ed25519.PrivateKey) (*SerializedAuctionResultTEE, error) {
	result := &SerializedAuctionResultTEE{}

	// Validate data commtiment
	if !serializedAD.ValidateHash() {
		return nil, fmt.Errorf("Auction data commitment does not match the expected hash")
	}

	auctionData, err := serializedAD.ToAuctionData()
	if err != nil {
		return nil, fmt.Errorf("could not convert serialized auction data to auction data: %v", err)
	}

	// Run the auction
	result.ResultBytes, err = runAuctionFunction(auctionData)
	if err != nil {
		return nil, fmt.Errorf("could not run auction function: %v", err)
	}

	// get report on the results
	err = result.setHardwareSignature()
	if err != nil {
		return nil, err
	}

	err = result.setAppSignature(privateKey)
	if err != nil {
		return nil, err
	}

	return result, nil

}

func runAuctionFunction(auctionData *cc_auction.AuctionData) ([]byte, error) {
	var errAuction, err error
	var coupledRes *cc_auction.OffChainCoupledAuctionResult
	var indepRes *cc_auction.OffChainIndepAuctionResult
	var resultBytes []byte

	if auctionData.Coupled {
		coupledRes, errAuction = cc_auction.RunCoupled(auctionData)
		resultBytes, err = json.Marshal(coupledRes)
	} else {
		indepRes, errAuction = cc_auction.RunIndependent(auctionData)
		resultBytes, err = json.Marshal(indepRes)
	}

	if err != nil || errAuction != nil {
		return nil, fmt.Errorf("could not run auction: %v, %v", err, errAuction)
	}

	return resultBytes, nil
}

func (result *SerializedAuctionResultTEE) setHardwareSignature() error {
	var err error
	reportUserData := sha512.Sum512(result.ResultBytes)

	result.AmdReportBytes, err = report.GetAmdSevSnpReport(reportUserData)
	if err != nil {
		return fmt.Errorf("Failed to get AMD SEV SNP report: %v", err)
	}

	return nil
}

func (result *SerializedAuctionResultTEE) setAppSignature(privateKey ed25519.PrivateKey) error {
	// ed25519 sign already hashes using sha512
	result.AppSignature = ed25519.Sign(privateKey, result.ResultBytes)
	return nil
}
