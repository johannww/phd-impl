package auction

import (
	"crypto/ed25519"
	"crypto/sha512"
	"fmt"

	cc_auction "github.com/johannww/phd-impl/chaincodes/carbon/auction"
	"github.com/johannww/phd-impl/tee_auction/go/report"
)

type AuctionResultTEE struct {
	matched
}

type SerializedAuctionResultTEE struct {
	// ResultBytes is a serialized
	ResultBytes []byte `json:"resultBytes"`
	// AmdReportBytes is a serialized &attest.SNPAttestationReport{}
	AmdReportBytes []byte `json:"reportBytes"`
	// AppSignature represents the signature with the key generated by the app
	// inside the TEE
	AppSignature []byte `json:"appSignature"`
}

// TODOHP: finish auction running on tee
func RunTEEAuction(
	serializedAD *cc_auction.SerializedAuctionData,
	privateKey ed25519.PrivateKey) (*SerializedAuctionResultTEE, error) {
	result := &SerializedAuctionResultTEE{}

	// Validate data commtiment
	if !serializedAD.ValidateHash() {
		return nil, fmt.Errorf("Auction data commitment does not match the expected hash")
	}

	auctionData, err := serializedAD.ToAuctionData()
	if err != nil {
		return nil, fmt.Errorf("could not convert serialized auction data to auction data: %v", err)
	}

	// Run the auction
	if auctionData.Coupled {
		cc_auction.RunCoupled(auctionData)
	} else {
		cc_auction.RunIndependent(auctionData)
	}

	// get report on the results
	err = result.setHardwareSignature()
	if err != nil {
		return nil, err
	}

	return result, nil

}

func (result *SerializedAuctionResultTEE) setHardwareSignature() error {
	var err error
	reportUserData := sha512.Sum512(result.ResultBytes)

	result.AmdReportBytes, err = report.GetAmdSevSnpReport(reportUserData)
	if err != nil {
		return fmt.Errorf("Failed to get AMD SEV SNP report: %v", err)
	}

	return nil
}

func (result *SerializedAuctionResultTEE) setAppSignature(privateKey ed25519.PrivateKey) error {
	// ed25519 sign already hashes using sha512
	result.AppSignature = ed25519.Sign(privateKey, result.ResultBytes)
	return nil
}
