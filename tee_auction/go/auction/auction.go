package auction

import (
	"crypto/ed25519"
	"crypto/sha512"
	"encoding/json"
	"errors"
	"fmt"

	cc_auction "github.com/johannww/phd-impl/chaincodes/carbon/auction"
	"github.com/johannww/phd-impl/chaincodes/carbon/policies"
	"github.com/johannww/phd-impl/tee_auction/go/report"
)

// type AuctionResultTEE struct {
// 	matched
// }

type SerializedAuctionResultTEE struct {
	// ResultBytes is a serialized OffChainIndepAuctionResult
	// Or OffChainCoupledAuctionResult
	ResultBytes  []byte `json:"resultBytes"`
	ReceivedHash []byte `json:"receivedHash"`
	// AmdReportBytes is a serialized &attest.SNPAttestationReport{}
	// AMD SEV-SNP report over report_data ResultBytes || ReceivedHash
	AmdReportBytes []byte `json:"reportBytes"`
	// AppSignature represents the signature with the key generated by the app
	// inside the TEE. AppSignature is over ResultBytes || ReceivedHash
	AppSignature []byte `json:"appSignature"`
	TEECertDer   []byte `json:"teeCertDer"`
}

// TODOHP: finish auction running on tee
func RunTEEAuction(
	serializedAD *cc_auction.SerializedAuctionData,
	privateKey ed25519.PrivateKey,
) (resultPub, resultPvt *SerializedAuctionResultTEE, err error) {
	resultPub = &SerializedAuctionResultTEE{}
	resultPvt = &SerializedAuctionResultTEE{}

	// Validate data commtiment
	if !serializedAD.ValidateHash() {
		return nil, nil, fmt.Errorf("Auction data commitment does not match the expected hash")
	}

	auctionData, err := serializedAD.ToAuctionData()
	if err != nil {
		return nil, nil, fmt.Errorf("could not convert serialized auction data to auction data: %v", err)
	}

	// Run the auction
	r := AuctionRunnerTEE{
		coupledRunner: &cc_auction.AuctionCoupledRunner{},
		indepRunner:   &cc_auction.AuctionIndepRunner{},
	}
	resultPub.ResultBytes, resultPvt.ResultBytes, err = r.runAuctionFunction(auctionData)
	if err != nil {
		return nil, nil, fmt.Errorf("could not run auction function: %v", err)
	}

	resultPub.ReceivedHash = serializedAD.Sum
	resultPvt.ReceivedHash = serializedAD.Sum

	// get report on the results
	err = resultPub.setHardwareSignature()
	err2 := resultPvt.setHardwareSignature()
	if err != nil || err2 != nil {
		return nil, nil, errors.Join(err, err2)
	}

	err = resultPub.setAppSignature(privateKey)
	err2 = resultPvt.setAppSignature(privateKey)
	if err != nil || err2 != nil {
		return nil, nil, errors.Join(err, err2)
	}

	return resultPub, resultPvt, nil
}

type AuctionRunnerTEE struct {
	coupledRunner *cc_auction.AuctionCoupledRunner
	indepRunner   *cc_auction.AuctionIndepRunner
}

func (r *AuctionRunnerTEE) runAuctionFunction(auctionData *cc_auction.AuctionData) ([]byte, []byte, error) {
	var errAuction, errPub, errPvt error
	var coupledResPub, coupledResPvt *cc_auction.OffChainCoupledAuctionResult
	var indepResPub, indepResPvt *cc_auction.OffChainIndepAuctionResult
	var resultBytesPub, resultBytesPvt []byte

	pApplier := policies.NewPolicyApplier()

	if auctionData.Coupled {
		coupledResPub, coupledResPvt, errAuction = r.coupledRunner.RunCoupled(auctionData, pApplier)
		resultBytesPub, errPub = json.Marshal(coupledResPub)
		resultBytesPvt, errPvt = json.Marshal(coupledResPvt)
	} else {
		// indepRes, errAuction = cc_auction.RunIndependent(auctionData)
		indepResPub, indepResPvt, errAuction = r.indepRunner.RunIndependent(auctionData)
		resultBytesPub, errPub = json.Marshal(indepResPub)
		resultBytesPvt, errPvt = json.Marshal(indepResPvt)
	}

	if errPub != nil || errPvt != nil || errAuction != nil {
		return nil, nil, fmt.Errorf("could not run auction: %v, %v, %v", errAuction, errPub, errPvt)
	}

	return resultBytesPub, resultBytesPvt, nil
}

func (result *SerializedAuctionResultTEE) setHardwareSignature() error {
	var err error
	// Join ResultBytes and ReceivedHash to form the report user data
	receivedResultAndBytes := []byte{}
	receivedResultAndBytes = append(receivedResultAndBytes, result.ResultBytes...)
	receivedResultAndBytes = append(receivedResultAndBytes, result.ReceivedHash...)
	reportUserData := sha512.Sum512(receivedResultAndBytes)

	result.AmdReportBytes, err = report.GetAmdSevSnpReport(reportUserData)
	if err != nil {
		return fmt.Errorf("Failed to get AMD SEV SNP report: %v", err)
	}

	return nil
}

func (result *SerializedAuctionResultTEE) setAppSignature(privateKey ed25519.PrivateKey) error {
	receivedResultAndBytes := []byte{}
	receivedResultAndBytes = append(receivedResultAndBytes, result.ResultBytes...)
	receivedResultAndBytes = append(receivedResultAndBytes, result.ReceivedHash...)
	// ed25519 sign already hashes using sha512
	result.AppSignature = ed25519.Sign(privateKey, receivedResultAndBytes)
	return nil
}
